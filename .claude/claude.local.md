# Claude.Local.MD

This file is used to store local configuration and settings for Claude. It is not intended to be shared or committed to version control.

This is intended to provide context for the current work session.

## IMPORTANT: Version Numbering

**DO NOT bump the version number in package.json unless explicitly asked by the user.**

The user will test changes before deciding to bump the version. Only increment the version when the user specifically requests it.

This project is an extension for VSCode, specifically to discover upstream methods that could be affected by code changes. It uses several methods, relying on the C# extensions already installed.

As currently implemented, the extension successfully identifies methods or interfaces at the current cursor position, and builds a tree of upstream methods that could be affected by changes to the selected method.

These are presented to the user in a tree view, allowing for easy navigation and exploration of the codebase.

Each line in this tree view has a checkbox, which the user can check to mark that line for further action, satisfying one ofthe use cases, i.e. to triage where action is needed in the code.

The extension also provides a command to export the selected lines to a markdown file, allowing for easy sharing and collaboration with other developers.

## Tree Data Structure

The tree has two types of nodes:

1. **Method nodes**: Represent methods that call other methods
   - Stored in `tree.children` array
   - Have properties: `name`, `namespace`, `file`, `line`, `character`
   - May have `httpAttribute` if it's a controller endpoint

2. **Reference location nodes**: The actual call sites (üìç pins in UI)
   - Stored in `tree.referenceLocations` array (NOT in children!)
   - Have properties: `file`, `line`, `character`
   - UI dynamically creates nodes with `isReference: true` flag for display

**CRITICAL**: The `referenceLocations` array items DO NOT have `isReference: true` in the data structure, but the UI nodes created from them DO. Any code that looks up checkbox states for references MUST add `isReference: true` when generating the key, or lookups will fail.

Checkbox states are stored in a Map using keys generated by `getNodeKey()`:
- Method nodes: `method:{file}:{line}:{name}`
- Reference nodes: `ref:{file}:{line}:{character}` (requires `isReference: true`)

Problem 1: ‚úÖ SOLVED

The tree pruning functionality now works correctly. The key issue was a **data structure mismatch** between UI nodes and tree data:

### Root Cause:
- Reference locations (üìç pins) are stored in the tree's `referenceLocations` array WITHOUT an `isReference` flag
- When creating UI nodes from these references, the code adds `isReference: true` to the node
- Checkbox states are keyed using `getNodeKey()` which generates DIFFERENT keys depending on whether `isReference` is present
- Result: When a user checks a reference in the UI, it's stored with key `ref:file:line:char`, but when pruning, the code looked it up with a different key format

### Solution Applied:
When checking reference locations during normalization and pruning, create a temporary object with `isReference: true` to ensure key consistency:
```typescript
const refAsUINode = {
    file: ref.file,
    line: ref.line,
    character: ref.character,
    isReference: true  // Critical for key matching!
};
const isRefChecked = this.getCheckboxState(refAsUINode);
```

### Key Learning:
**When UI presentation differs from underlying data structure, ensure consistent key generation throughout the codebase.** Always trace through how data is stored vs. how it's retrieved - mismatches in object structure (even a single boolean flag) can cause complete lookup failures.

### Implementation Notes:
- The recursive traversal logic was correct from the start
- Debug output is now configurable via `nixUpstreamCheck.enablePruneDebugOutput` setting
- See `normalizeCheckStates()` at line ~909 and `pruneUncheckedItems()` at line ~1054 in extension.ts

## Debugging Tips for Future Sessions

When debugging issues with tree operations (pruning, checkbox states, etc.):

1. **Enable debug output**: Set `nixUpstreamCheck.enablePruneDebugOutput` to `true` in VSCode settings
2. **Check key generation**: Use debug output to verify keys being generated match keys being looked up
3. **Test incrementally**:
   - First test with single leaf node checked
   - Then test with parent manually checked
   - Compare behavior to isolate the issue
4. **Build VSIX for real testing**: Always test in real dev environment, not just Extension Development Host, as some behaviors differ
5. **When pruning seems broken**: The issue is almost always key mismatch or not traversing all nodes. Check:
   - Are all nodes being visited? (debug output shows this)
   - Are keys consistent between storage and retrieval?
   - Are reference locations being handled with `isReference: true` flag?

## Testing Strategy That Worked

1. Disable deletion temporarily (comment out pruning code)
2. Add verbose debug logging to see what's happening
3. Test with screenshots BEFORE and AFTER to show what changed
4. Once normalization (auto-checking parents) works, re-enable deletion
5. Move debug output behind configuration flag for production

Problem 2: Class Change Impact Analysis

The need to triage for upstream changes can also be triggered by a change to a class definition (e.g., adding a property). The goal is to identify where this class is used in ways that might be affected by the change.

### Specific Requirements:

When a class is selected, identify references where the class is:
1. **[N] New/Instantiation** - `new MyClass()` - Creating new instances
2. **[P] Parameter** - Methods that accept the class as a parameter

**Not needed**: Variable declarations/assignments can be ascertained through other means.

### Approach:

1. Detect when cursor is on a class definition (`class MyClassName` or `public class MyClassName`)
2. Use VSCode's Reference Provider to find all references to the class
3. For each reference, determine if it's:
   - A `new` instantiation ‚Üí Mark as **N**
   - A method parameter ‚Üí Mark as **P**
   - Skip other reference types (variable declarations, return types, etc.)
4. Build the upstream call tree from methods containing **N** or **P** references
5. Display in the same tree structure with type indicators

### Implementation Notes:

- Class detection regex: `/\b(?:public|private|protected|internal)?\s*(?:abstract|sealed|static|partial)?\s*class\s+(\w+)/`
- For instantiation detection: Look for `new ClassName(` pattern in the reference line
- For parameter detection: Check if the reference is inside method parameter list (between method name's `(` and method body's `{`)
- Reuse existing tree structure and pruning logic
- Add **N** and **P** to type indicators alongside **M, C, S, O, I**
